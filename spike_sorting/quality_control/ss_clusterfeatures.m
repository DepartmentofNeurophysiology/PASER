function clusters = ss_clusterfeatures(spikes)

spikes = ss_default_params(spikes);

% Remove small clusters

clusterIDs = unique(spikes.assigns);
nclusters  = length(clusterIDs);

for icluster = 1:nclusters
    clusterID = clusterIDs(icluster);
    id        = find(spikes.assigns == clusterID);
    if (length(id) <= spikes.params.qc.cluster_min)
        spikes = ss_spike_removal(spikes,id);
    end
end

% Calculate features of remaining clusters

clusterIDs = unique(spikes.assigns);
nclusters  = length(clusterIDs);

clusters.bhattacharyya = zeros(nclusters,nclusters);
clusters.mahal         = zeros(nclusters,nclusters);

for icluster = 1:nclusters
        
    clusterID = clusterIDs(icluster);
    nspikes = sum(spikes.assigns == clusterID);    
        
    % A real neuron has a brief period after each spike when it cannot fire
    % again, called the refractory period. This function uses the number of
    % inter-spike intervals (ISIs) that are less than the refractory period to
    % estimate a contamination rate.
    
    % The logic of this function is detailed in rpv_contamination, but the
    % essential statistical assumption is that contaminating spikes which cause
    % refractory period violations occur at times that are uncorrelated with
    % the spike times of true spikes in the cluster. This function also returns
    % 95% confidence levels on the estimate which make the further assumption
    % of Poisson statistics.
    
    % Output:
    %   ev   - expected value of % contamination,
    %   lb   - lower bound on % contamination, using 95% confidence interval
    %   ub   - upper bound on % contamination, using 95% confidence interval
    %   RPV  - number of refractory period violations observed in this cluster
    
    [~,~,~,RPV] = ss_rpv_contamination(spikes, clusterID);
    
    RPVP = RPV / nspikes;
        
    % This function estimates false negative errors due to a detection
    % threshold that is too high for the cluster. The function assumes that
    % detection was performed using a simple negative voltage threshold. A
    % histogram is created of the peak voltage for each waveform and is fitted
    % with a Gaussian. A special fitting function is used since the tail of the
    % Gaussian distribution is assumed missing due to the detection threshold.
    % The integral of the missing tail is returned as an estimate of the
    % probability of false negatives.
    
    % In the case of multi-channel data, the waveform on each channel is
    % normalized by the detection threshold on that channel. Then only the most
    % negative value across all channels is saved for the histogram.
    
    % Output:
    %  p     - estimate of probability that a spike is missing because it didn't reach threshhold
    %  mu    - mode estimated for distribution of minimum values
    %  stdev - standard deviation estimated for distribution of minimum values
    %  n     - bin counts for histogram used to fit Gaussian
    %  x     - bin centers for histogram used to fit Gaussian
    
    [p,~,~,~,~] = ss_undetected(spikes, clusterID);
        
    % Every detected event is followed by a brief “censored” or “shadow” period
    % where no further spike can be detected. This feature is included in
    % ss_detect so that a single spike event does not trigger multiple
    % detection events. However, if events are detected at a high rate (> 50
    % Hz) then these shadow periods can become a significant percentage of the
    % data set. This function calculate what percent of the experiment is
    % censored by events outside of the given cluster, thus giving another
    % false negative probability.
    
    % Note that “censored” events, “undetected” events, and the overall false
    % negative probability estimated by Gaussian overlap are mutually
    % exclusive. Therefore, these 3 estimates of false negative errors can be
    % simply added to get a final estimate of false negative errors.
    
    % Output:
    %  c - estimated false negative fraction from censoring

    c = ss_censored(spikes, clusterID);
    
    % Cross-correlation of residuals
    
    [xc,IDc] = cross_correlation(spikes, clusterID);
    
%     for jcluster = icluster:nclusters
%         
%         % This function estimates false positives and false negatives from the
%         % spike waveforms of two different clusters. An error probability is
%         % estimated by assuming that the two clusters were generated by a mixture
%         % of 2 multivariate Gaussian distributions. The parameters of this
%         % distribution are fit using the Statistics toolbox function
%         % gmdistribution.fit. Be aware when using this function that a two Gaussian
%         % model may not be suited to your pair of clusters. Non-Gaussian
%         % variability occurs during electrode drift, bursting, poor clustering,
%         % etc… Use the visualization tools to diagnose this. Based on the Gaussian
%         % models, this function outputs a confusion matrix that gives an estimate
%         % of the false negative and positive errors for each of the two clusters.
%         % If C is the confusion matrix, then
%         % C(1,1) is the probability of a false positive for cluster 1
%         % C(1,2) is the probability of a false negative for cluster 1
%         % C(2,1) is the probability of a false negative for cluster 2
%         % C(2,2) is the probability of a false positive for cluster 2
%         % This function should be applied to every pair of clusters to get an
%         % overall estimate of false positive and negative rates. All false positive
%         % probabilities for a particular cluster are independent and so should be
%         % combined by multiplying the compliments, The same is true for the false
%         % negative probabilities.
%         
%         % Note that the false positives events estimated from refractory period
%         % violations is not independent from the false positive events estimated
%         % from Gaussian overlap. Therefore, it is recommended to use which ever
%         % estimate is larger.
%         
%         confusion = ss_gaussian_overlap(spikes, icluster, jcluster);
%         
%     end
    
    clusters.vars(icluster).id       = clusterID;
    clusters.vars(icluster).rpv      = RPVP;
    clusters.vars(icluster).missing  = p; 
    clusters.vars(icluster).censored = c;
    clusters.vars(icluster).nspikes  = nspikes;
    clusters.vars(icluster).xcorr    = xc;
    clusters.vars(icluster).flag     = abs_threshold(spikes,clusterID);
    clusters.vars(icluster).chanIDs  = IDc;
    
    if     (clusters.vars(icluster).rpv < spikes.params.qc.lower_rpv); clusters.vars(icluster).unit = 'single';
    elseif (clusters.vars(icluster).rpv > spikes.params.qc.upper_rpv); clusters.vars(icluster).unit = 'multi';
    else                                                               clusters.vars(icluster).unit = 'mixed';
    end
        
    for jcluster = (icluster+1):nclusters
        M1 = PCA_M(spikes,find(spikes.assigns == clusterID));
        M2 = PCA_M(spikes,find(spikes.assigns == clusterIDs(jcluster)));
        D  = mahal(M1,M2);
        clusters.mahal(icluster,jcluster) = mean(D(:));
        
        [x1,x2,~] = plot_fld(spikes, clusterID, clusterIDs(jcluster), 0);
        clusters.bhattacharyya(icluster,jcluster) = bhattacharyya(x1',x2');
%         clusters.mahal(icluster,jcluster)         = mean(mahal(x1',x2'));
    end
end

end

function [xc,IDc] = cross_correlation(spikes, show)

% calculate standard deviation
clus         = get_spike_indices(spikes, show);
memberwaves  = spikes.waveforms(clus,:);
num_channels = size(spikes.waveforms,3);
num_samples  = size(spikes.waveforms,2);
s            = std(memberwaves);

% calculate cross-correlation

xc = zeros(num_channels); % cross-correlation matrix
sd = reshape(s,num_samples,num_channels); % residuals for each channel separately

for ichan = 1:num_channels
    for jchan = ichan:num_channels
        xc(ichan,jchan) = xcorr(sd(:,ichan),sd(:,jchan),0,'coeff'); % xcorr with zero lag
    end
end

waves = reshape(mean(memberwaves),num_samples,num_channels);

id = zeros(num_channels,1);
for ichan = 1:num_channels
    id(ichan) = double(max(sign(spikes.info.detect.thresh(ichan)) .* waves(:,ichan)) >= sign(spikes.info.detect.thresh(ichan)) .* spikes.info.detect.thresh(ichan)); % check which channels are active
end

IDc = find(id);
id  = id' * id; 
id  = id(:);
xc  = xc(:);
xc(id == 0) = []; % ignore channels that do not display spike 
if (~isempty(xc)); xc = mean(xc);
else               xc = 0; 
end

end

function k = abs_threshold(spikes, show)

clus         = get_spike_indices(spikes, show);
memberwaves  = spikes.waveforms(clus,:);
waves_mean   = mean(memberwaves);
k            = max(sign(spikes.params.outlier.abs) * waves_mean > sign(spikes.params.outlier.abs) * spikes.params.outlier.abs);

end

function M = PCA_M(spikes,which)

    x = spikes.waveforms(which,:) * spikes.info.pca.v(:,1);
    y = spikes.waveforms(which,:) * spikes.info.pca.v(:,2);
    z = spikes.waveforms(which,:) * spikes.info.pca.v(:,3);

    M  = [x,y,z];

end